{
  "$schema": "https://inlang.com/schema/inlang-message-format",
  "nav_blog": "Blog",
  "nav_expertise": "Expertise",
  "nav_versatility": "Versatility",
  "nav_principles": "Principles",
  "nav_projects": "Projects",
  "nav_experience": "Experience",
  "hero_location": "LOCATION",
  "hero_about": "ABOUT",
  "hero_contact": "CONTACT",
  "hero_email": "Email",
  "hero_github": "GitHub",
  "hero_linkedin": "LinkedIn",
  "hero_company": "Company",
  "hero_viewResume": "View Resume",
  "blog_title": "Blog",
  "blog_subtitle": "Technical notes, architectural insights, and thoughts on the evolving software landscape.",
  "blog_viewAll": "View all posts",
  "blog_backToBlog": "Back to blog",
  "blog_previousPost": "Previous Post",
  "blog_nextPost": "Next Post",
  "blog_readMore": "Read more",
  "expertise_title": "Expertise",
  "expertise_primary": "PRIMARY",
  "expertise_secondary": "SECONDARY",
  "expertise_tertiary": "TERTIARY",
  "expertise_primaryLevel": "Primary Expertise",
  "expertise_secondaryLevel": "Secondary Focus",
  "expertise_tertiaryLevel": "Tertiary Skills",
  "expertise_coreCompetencies": "Core Competencies",
  "expertise_supportingSkills": "Supporting Skills",
  "versatility_title": "Versatility",
  "versatility_subtitle": "A broad technical foundation across the full development spectrum",
  "versatility_intro": "As a problem solver, I believe specialization is limiting.",
  "versatility_p1": "Technology is a tool, not an identity. The moment you define yourself by a specific language or framework, you start making biased architectural decisions. A Python expert might force Python solutions where JavaScript would be better, simply because that's their comfort zone.",
  "versatility_p2": "Today, with AI as my amplifier, the gap between knowing a technology and being an expert has practically disappeared. I can architect solutions in any language, leverage any framework, and implement using any paradigm because AI handles the syntax while I focus on the system design.",
  "versatility_p3": "What matters is understanding patterns, principles, and trade-offs. The rest is just implementation details that AI can help with instantly. This approach lets me choose the right tool for each problem, not the tool I'm most familiar with.",
  "principles_title": "Principles",
  "principles_subtitle": "Core philosophies that guide my approach to software development",
  "projects_title": "Projects",
  "projects_subtitle": "Real-world solutions built with modern tools and architectural thinking",
  "projects_role": "Role",
  "projects_problem": "Problem",
  "projects_approach": "Approach",
  "projects_outcome": "Outcome",
  "projects_stack": "Stack",
  "projects_metrics": "Metrics",
  "projects_impactMetrics": "Impact Metrics",
  "projects_technologyStack": "Technology Stack",
  "experience_title": "Experience",
  "experience_subtitle": "Journey from academic foundations to real-world technical leadership",
  "experience_skills": "Skills",
  "experience_impact": "Impact",
  "experience_keyAchievements": "Key Achievements",
  "experience_skillsGained": "Skills Gained",
  "footer_viewSource": "View Source",
  "theme_switchTo": "Switch to {mode} mode",
  "language_switchTo": "Switch to {language}",
  "language_en": "English",
  "language_es": "Espa√±ol",
  "arcade_title": "Arcade",
  "arcade_subtitle": "Take a break with this retro classic",
  "arcade_game_breakout": "Breakout",
  "arcade_game_breakout_desc": "Classic brick-breaking action. Destroy all bricks with the ball.",
  "arcade_score": "Score",
  "arcade_highscore": "High Score",
  "arcade_gameover": "Game Over",
  "arcade_presskey": "Press SPACE to start",
  "arcade_lives": "Lives"
}
